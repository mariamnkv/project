#include <iostream>             // Подключаем библиотеку для ввода/вывода (cout, cin)
#include <vector>               // Подключаем библиотеку для работыкция _getch)
#include <windows.h>            // Подключаем Windows API для работы с консолью (SetConsoleOutputC с динамическими массивами (vector)
#include <conio.h>              // Подключаем библиотеку для работы с консольным вводом (фунP)
#include <ctime>                // Подключаем библиотеку для работы со временем (time, srand)

using namespace std;            // Используем стандартное пространство имён, чтобы не писать std:: перед элементами стандартной библиотеки

// Определяем структуру Theme, которая хранит символы для различных элементов оформления игры
struct Theme {
    string PLAYER, MONSTER, WALL, POINT, BONUS, EMPTY = "  ";
};

int WIDTH, HEIGHT;              // Глобальные переменные для хранения ширины и высоты игрового уровня
int attempts = 1;               // Счётчик попыток прохождения уровня, изначально равен 1
bool gameOver;                  // Флаг, сигнализирующий о завершении игры

// Структура Entity описывает сущность с координатами (игрока или монстров)
struct Entity {
    int x, y;                   // Координаты сущности на уровне
};

Entity player;                  // Глобальная переменная для игрока
vector<Entity> monsters;        // Вектор для хранения всех монстров на уровне

// Определяем разные темы оформления игры с соответствующими символами
Theme SEA    = {"🐠", "🦈", "🪸", "⚪", "⭐"};   // Тема "Морская"
Theme FOREST = {"🐰", "🐺", "🌲", "🍄", "🥕"};   // Тема "Лесная"
Theme CITY   = {"🚗", "👮", "🚧", "🛞", "💎"};   // Тема "Городская"
Theme SPACE  = {"🚀", "👾", "🌑", "✨", "🌟"};   // Тема "Космическая"

vector<Theme> themes = {SEA, FOREST, CITY, SPACE};  // Вектор, содержащий все доступные темы оформления

#include <unordered_map>      // Подключаем библиотеку для работы с ассоциативными контейнерами (unordered_map)

// Объявляем словарь (unordered_map) для хранения уровней игры по темам
// Ключ – название темы, значение – вектор уровней, каждый уровень представлен матрицей строк
unordered_map<string, vector<vector<vector<string>>>> LevelsByTheme = {
    {"SEA", {
        {{"🪸","🪸","🪸","🪸","🪸","🪸","🪸"},
         {"🪸","🐠","⚪","  ","🪸","⚪","🪸"},
         {"🪸","  ","🪸","  ","⚪","  ","🪸"},
         {"🪸","⚪","  ","🪸","  ","🦈","🪸"},
         {"🪸","⚪","  ","⚪","🪸","  ","🪸"},
         {"🪸","🦈","  ","  ","  ","⚪","🪸"},
         {"🪸","🪸","🪸","🪸","🪸","🪸","🪸"}}
    }},
    
    {"FOREST", {
        {{"🌲","🌲","🌲","🌲","🌲","🌲","🌲"},
         {"🌲","🐰","🍄","  ","🌲","🍄","🌲"},
         {"🌲","  ","🌲","  ","🍄","  ","🌲"},
         {"🌲","🍄","🌲","🍄","  ","🐺","🌲"},
         {"🌲","  ","🌲","  ","🌲","  ","🌲"},
         {"🌲","🍄","  ","🍄","  ","🍄","🌲"},
         {"🌲","🌲","🌲","🌲","🌲","🌲","🌲"}}
    }},
    
    {"CITY", {
        {{"🚧","🚧","🚧","🚧","🚧","🚧","🚧"},
         {"🚧","🚗","⚪","  ","🚧","⚪","🚧"},
         {"🚧","  ","🚧","  ","⚪","  ","🚧"},
         {"🚧","⚪","🚧","⚪","🚧","👮","🚧"},
         {"🚧","  ","  ","  ","⚪","  ","🚧"},
         {"🚧","⚪","  ","⚪","  ","⚪","🚧"},
         {"🚧","🚧","🚧","🚧","🚧","🚧","🚧"}}
    }},
    
    {"SPACE", {
        {{"🌑","🌑","🌑","🌑","🌑","🌑","🌑"},
         {"🌑","🚀","✨","  ","🌑","✨","🌑"},
         {"🌑","  ","🌑","  ","✨","  ","🌑"},
         {"🌑","✨","🌑","✨","🌑","👾","🌑"},
         {"🌑","  ","  ","  ","✨","  ","🌑"},
         {"🌑","✨","  ","✨","  ","✨","🌑"},
         {"🌑","🌑","🌑","🌑","🌑","🌑","🌑"}}
    }}
};

Theme currentTheme = SEA;     // Глобальная переменная для хранения текущей выбранной темы, по умолчанию – Морская

vector<vector<string>> currentLevel; // Глобальная переменная для хранения текущего уровня игры 

// Функция для настройки уровня 
void setupLevel(int levelNum, string themeName) {
    currentLevel = LevelsByTheme[themeName][levelNum];  // Выбираем нужный уровень из словаря по теме и номеру
    HEIGHT = currentLevel.size();                        // Устанавливаем высоту уровня (количество строк)
    WIDTH = currentLevel[0].size();                      // Устанавливаем ширину уровня (количество столбцов в первой строке)
    monsters.clear();                                    // Очищаем вектор монстров (на случай перезапуска уровня)

    for (int y = 0; y < HEIGHT; y++) {                   // Проходим по каждой строке уровня
        for (int x = 0; x < WIDTH; x++) {                // Проходим по каждому столбцу в строке
            string &cell = currentLevel[y][x];           // Получаем ссылку на текущую ячейку уровня

            // Автоматическая замена символов на символы текущей темы
            if (cell == "🐠" || cell == "🐰" || cell == "🚗" || cell == "🚀") {
                player = {x, y};                         // Если ячейка содержит символ игрока, устанавливаем позицию игрока
                cell = currentTheme.PLAYER;              // Заменяем символ на символ игрока из текущей темы
            } else if (cell == "🦈" || cell == "🐺" || cell == "👮" || cell == "👾") {
                monsters.push_back({x, y});              // Если ячейка содержит символ монстра, добавляем монстра в вектор
                cell = currentTheme.MONSTER;             // Заменяем символ на символ монстра из текущей темы
            } else if (cell == "🪸" || cell == "🌲" || cell == "🚧" || cell == "🌑") {
                cell = currentTheme.WALL;                // Если ячейка содержит символ стены, заменяем его на символ стены из темы
            } else if (cell == "⚪" || cell == "🍄" || cell == "🛞" || cell == "✨") {
                cell = currentTheme.POINT;               // Если ячейка содержит символ очков, заменяем его на символ очков из темы
            } else if (cell == "⭐" || cell == "🥕" || cell == "💎" || cell == "🌟") {
                cell = currentTheme.BONUS;               // Если ячейка содержит символ бонуса, заменяем его на символ бонуса из темы
            } else {
                cell = currentTheme.EMPTY;               // Если символ не распознан, заменяем его на пустое пространство из темы
            }
        }
    }
}

// Функция для отрисовки уровня в консоли
void drawLevel() {
    system("cls");                                     // Очищаем консоль (команда для Windows)
    cout << "Попытка: " << attempts << endl;           // Выводим номер текущей попытки
    for (auto &row : currentLevel) {                   // Проходим по каждой строке уровня
        for (auto &cell : row)                         // Проходим по каждой ячейке в строке
            cout << cell << " ";                       // Выводим символ ячейки и пробел для разделения
        cout << endl;                                  // Переходим на новую строку после каждой строки уровня
    }
    cout << "\nУправление: W A S D | ESC - выход\n";    // Выводим подсказку по управлению
}

// Функция для проверки, пройден ли уровень (то есть, отсутствуют ли на уровне символы очков или бонусов)
bool checkWin() {
    for (auto &row : currentLevel)                     // Проходим по каждой строке уровня
        for (auto &cell : row)                         // Проходим по каждой ячейке строки
            if (cell == currentTheme.POINT || cell == currentTheme.BONUS)
                return false;                          // Если найдены очки или бонусы, уровень ещё не пройден
    return true;                                       // Если все очки и бонусы собраны, уровень пройден
}

// Функция для проверки столкновения (стеной или монстром) в указанной ячейке
bool checkCollision(int x, int y) {
    return (currentLevel[y][x] == currentTheme.WALL ||
            currentLevel[y][x] == currentTheme.MONSTER);  // Возвращает true, если в ячейке находится стена или монстр
}

// Функция для перемещения монстров
void moveMonsters() {
    for (auto &m : monsters) {                          // Проходим по каждому монстру в векторе
        int nx = m.x, ny = m.y;                         // Изначально новая позиция монстра равна его текущей позиции
        switch(rand() % 4) {                            // Выбираем случайное направление (0–3)
            case 0: ny--; break;                        // Если выпало 0 – двигаемся вверх
            case 1: ny++; break;                        // Если 1 – двигаемся вниз
            case 2: nx--; break;                        // Если 2 – двигаемся влево
            case 3: nx++; break;                        // Если 3 – двигаемся вправо
        }
        // Проверяем, что новая позиция находится в пределах уровня и ячейка пуста
        if (nx >= 0 && ny >= 0 && nx < WIDTH && ny < HEIGHT &&
            currentLevel[ny][nx] == currentTheme.EMPTY) {
            currentLevel[m.y][m.x] = currentTheme.EMPTY; // Очищаем предыдущую позицию монстра
            m.x = nx; m.y = ny;                         // Обновляем координаты монстра
            currentLevel[m.y][m.x] = currentTheme.MONSTER; // Помещаем монстра в новую позицию
        }
    }
}

// Основной игровой цикл для прохождения уровня
void gameLoop(int levelNum, string themeName) {
    setupLevel(levelNum, themeName);  // Загружаем выбранный уровень с заданной темой
    char input;                       // Переменная для хранения ввода с клавиатуры
    gameOver = false;                // Изначально игра не завершена

    while (!gameOver) {              // Цикл, который выполняется до завершения игры
        drawLevel();               // Отрисовываем текущий уровень

        if (checkWin()) {          // Если уровень пройден (нет очков и бонусов)
            drawLevel();           // Отрисовываем уровень ещё раз
            cout << "🎉 Уровень пройден! 🎉\n";  // Выводим сообщение об успешном прохождении

            // Проверяем, существует ли следующий уровень для выбранной темы
            if (levelNum + 1 < LevelsByTheme[themeName].size()) {
                cout << "Перейти на следующий уровень? (Y/N): "; // Спрашиваем, хочет ли игрок продолжить
                char next = _getch();          // Получаем выбор игрока (без нажатия Enter)
                if (next == 'Y' || next == 'y') {  // Если игрок выбирает продолжить
                    attempts = 1;             // Сбрасываем счётчик попыток
                    gameLoop(levelNum + 1, themeName);  // Запускаем следующий уровень (рекурсивно)
                } else {
                    cout << "Спасибо за игру!\n";  // Если игрок отказывается, благодарим за игру
                    _getch();             // Ожидаем нажатия клавиши
                    return;               // Завершаем игровой цикл
                }
            } else {
                cout << "🎉 Ты прошёл последний уровень! 🎉\n";  // Если уровней больше нет, сообщаем об окончании игры
                _getch();             // Ожидаем нажатия клавиши
                return;               // Выходим из функции
            }
        }

        input = _getch();           // Получаем ввод с клавиатуры
        if (input == 27) break;     // Если нажата клавиша ESC (ASCII 27), выходим из игрового цикла

        int newX = player.x, newY = player.y;  // Инициализируем новые координаты игрока его текущим положением
        switch(input) {             // Обрабатываем ввод для перемещения игрока
            case 'W': case 'w': newY--; break;
            case 'S': case 's': newY++; break;
            case 'A': case 'a': newX--; break; 
            case 'D': case 'd': newX++; break; 
            default: continue;       // Если нажата другая клавиша – пропускаем итерацию цикла
        }

        // Проверяем, что новые координаты не выходят за границы уровня
        if (newX < 0 || newY < 0 || newX >= WIDTH || newY >= HEIGHT) continue;

        // Если при перемещении происходит столкновение со стеной или монстром
        if (checkCollision(newX, newY)) {
            drawLevel();           // Отрисовываем уровень
            cout << "💀 Ты умер! Попробовать снова? (Y/N): ";  // Сообщаем о смерти
            char retry = _getch();  // Получаем выбор игрока
            if (retry == 'Y' || retry == 'y') {  // Если игрок выбирает повторить попытку
                attempts++;         // Увеличиваем счётчик попыток
                setupLevel(levelNum, themeName); // Перезапускаем текущий уровень
                continue;           // Возобновляем игровой цикл
            } else {
                cout << "Конец игры. Спасибо за игру!"; // Если игрок отказывается, выводим прощальное сообщение
                _getch();           // Ожидаем нажатия клавиши
                return;             // Завершаем функцию
            }
        }

        // Если игрок перемещается на ячейку с очками, очищаем эту ячейку
        if (currentLevel[newY][newX] == currentTheme.POINT)
            currentLevel[newY][newX] = currentTheme.EMPTY;

        currentLevel[player.y][player.x] = currentTheme.EMPTY;  // Очищаем предыдущую позицию игрока
        player = {newX, newY};                        // Обновляем позицию игрока
        currentLevel[player.y][player.x] = currentTheme.PLAYER;  // Отмечаем новую позицию символом игрока

        moveMonsters();              // Перемещаем всех монстров

        // Если после перемещения монстров игрок столкнулся с монстром или стеной
        if (checkCollision(player.x, player.y)) {
            drawLevel();           // Отрисовываем уровень
            cout << "💀 Монстр тебя поймал! Попробовать снова? (Y/N): ";  // Сообщаем, что монстр поймал игрока
            char retry = _getch();  // Получаем выбор игрока
            if (retry == 'Y' || retry == 'y') { // Если игрок хочет попробовать снова
                attempts++;        // Увеличиваем счётчик попыток
                setupLevel(levelNum, themeName); // Перезапускаем уровень
            } else {
                cout << "Конец игры. Спасибо за игру!"; // Если игрок отказывается, выводим прощальное сообщение
                _getch();           // Ожидаем нажатия клавиши
                return;             // Завершаем игру
            }
        }
    }
}

// Главная функция программы
int main() {
    SetConsoleOutputCP(CP_UTF8);    // Устанавливаем кодировку консоли на UTF-8 для корректного отображения эмодзи и символов
    srand(time(nullptr));           // Инициализируем генератор случайных чисел текущим временем

    // Выводим меню выбора темы игры
    cout << "🎮 Выбери тему игры 🎮\n";
    cout << "1. 🌊 Морская (SEA)\n";
    cout << "2. 🌲 Лесная (FOREST)\n";
    cout << "3. 🚗 Городская (CITY)\n";
    cout << "4. 🚀 Космическая (SPACE)\n";
    cout << "\nТвой выбор (1-4): ";

    char themeChoice = _getch();    // Получаем выбор темы без необходимости нажимать Enter
    string themeName;               // Переменная для хранения имени выбранной темы
    int themeIndex = 0;             // Переменная для хранения индекса выбранной темы в векторе themes

    // Обрабатываем выбор темы на основе введённого символа
    switch(themeChoice) {
        case '1': themeName = "SEA"; themeIndex = 0; break;        // Если выбрана "1" – устанавливаем тему "SEA"
        case '2': themeName = "FOREST"; themeIndex = 1; break;       // Если выбрана "2" – устанавливаем тему "FOREST"
        case '3': themeName = "CITY"; themeIndex = 2; break;         // Если выбрана "3" – устанавливаем тему "CITY"
        case '4': themeName = "SPACE"; themeIndex = 3; break;        // Если выбрана "4" – устанавливаем тему "SPACE"
        default:
            cout << "\nНекорректный выбор, установлена тема по умолчанию (Морская).\n";  // Если выбор некорректный, по умолчанию выбирается тема "SEA"
            themeName = "SEA";
            themeIndex = 0;
            system("pause");       // Приостанавливаем выполнение для того, чтобы игрок увидел сообщение
    }

    currentTheme = themes[themeIndex];   // Устанавливаем текущую тему, используя выбранный индекс

    cout << "\nТы выбрал: " << themeName << " тему!\n"; // Выводим сообщение с выбранной темой
    system("pause");                   // Приостанавливаем выполнение для ознакомления с выбором

    gameLoop(0, themeName);  // Запускаем игровой цикл, начиная с уровня 0 и выбранной темы

    return 0;                // Завершаем программу, возвращая 0 (успешное завершение)
}
